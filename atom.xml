<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Leewin’s Blog]]></title>
  <subtitle><![CDATA[□PM □UX ☑Dev]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leewin0821.github.io/"/>
  <updated>2015-03-05T12:31:32.343Z</updated>
  <id>http://leewin0821.github.io/</id>
  
  <author>
    <name><![CDATA[Leeiwn]]></name>
    <email><![CDATA[leewin.zhang@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[【Leewin的笔记】Good Design of Objects Note]]></title>
    <link href="http://leewin0821.github.io/2015/03/05/Good%20Design%20of%20Objects/"/>
    <id>http://leewin0821.github.io/2015/03/05/Good Design of Objects/</id>
    <published>2015-03-05T12:20:23.000Z</published>
    <updated>2015-03-05T12:24:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="良好对象的设计">良好对象的设计</h2>
<h3 id="类和对象">类和对象</h3>
<p>类的主要职责是根据需要<strong>创建</strong>对象，以及它们不再被使用的时候<strong>销毁</strong>它们。类知道它的孩子长什么样、如何表现。换言之，类知道它们遵循的合约。</p>
<h3 id="1-_对象存在于现实生活中">1. 对象存在于现实生活中</h3>
<p>一个良好的对象，它一定可以映射到现实生活中的某个实体。如果不能，请重构。</p>
<h3 id="2-_对象根据合约办事">2. 对象根据合约办事</h3>
<p>一个良好的对象总是根据合约办事，它被期望工作是因为它遵循合约而不是它的个人优点。所有良好的对象的每个公共方法都应该实现接口中对应的方法，如果对象有公共方法没有实现任何接口，那就是糟糕的设计。</p>
<p>原因有二：</p>
<ul>
<li>首先，一个没有合约的对象不能在单元测试中进行模拟（mock）。</li>
<li>另外，无合约的对象不能通过装饰（decoration）来扩展。</li>
</ul>
<h3 id="3-_对象应该是独特的">3. 对象应该是独特的</h3>
<p>一个良好的对象应当总是封装一些东西以保持独特性，否则这个对象可能就有完全一样的克隆体，下面是一个可能有克隆的糟糕对象的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class HTTPStatus implements Status {</div><div class="line">  <span class="keyword">private</span> URL page = <span class="keyword">new</span> URL(<span class="string">"http://www.google.com"</span>);</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">return</span> HttpURLConnection.class.cast(</div><div class="line">      <span class="keyword">this</span>.page.openConnection()</div><div class="line">    ).getResponseCode();</div></pre></td></tr></table></figure>

<p>我可以创建很多HTTPStatus类的实例，但是它们都是相等的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">first = <span class="keyword">new</span> HTTPStatus();</div><div class="line">second = <span class="keyword">new</span> HTTPStatus();</div><div class="line"><span class="keyword">assert</span> first.equals(second);</div></pre></td></tr></table></figure>

<p>很明显，实用类（utility classes）可能只包含静态方法，不能实例化良好对象，严格意义上说甚至不能称作“类”。</p>
<h3 id="4-_对象是不可变的">4. 对象是不可变的</h3>
<p>一个良好的对象应该永远不改变它封装的状态。值得注意的是，不可变性并不意味着所有方法都应该返回相同的值。相反，一个良好的不可变对象是非常动态的。然后它不应该改变它的内部状态。比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Immutable</span></div><div class="line"><span class="keyword">final</span> class HTTPStatus implements Status {</div><div class="line">  <span class="keyword">private</span> URL page;</div><div class="line">  <span class="keyword">public</span> <span class="title">HTTPStatus</span>(URL url) {</div><div class="line">    <span class="keyword">this</span>.page = url;</div><div class="line">  }</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">return</span> HttpURLConnection.class.cast(</div><div class="line">      <span class="keyword">this</span>.page.openConnection()</div><div class="line">    ).getResponseCode();</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>尽管read()方法返回不同的值，但是这个对象仍然是不可变的。关于对象不可变性的优点，有如下：</p>
<ul>
<li>不可变对象创建、测试和使用更加简单</li>
<li>真正的不可变对象总是线程安全的</li>
<li>它们可以帮助避免时间耦合</li>
<li>它们的用法没有副作用，即没有防御性拷贝</li>
<li>它们总是具有失败原子性，即如果方法失败，那么对象状态应该与方法调用前一致</li>
<li>它们更容易缓存</li>
<li>它们可以防止空引用</li>
</ul>
<p>当然，一个良好的对象不应该有setter方法，因为这些方法可以改变它的状态。</p>
<h3 id="5-_对象的类不应该包含任何静态（static）的东西">5. 对象的类不应该包含任何静态（static）的东西</h3>
<p>一个静态方法实现了类的行为，而不是对象的。假设我们有个类File，它的实例都拥有size()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> class File implements Measurable {</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">    <span class="comment">// calculate the size of the file and return</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前为止，一切都还好；size()方法的存在是因为合约Measurable，每个File类的对象都可以测量自身的大小。<strong>一个可怕的错误是将类的这个方法设计为静态方法</strong>（这种类被称作实用类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕的设计，请勿使用！</span></div><div class="line">class File {</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">size</span>(String file) {</div><div class="line">    <span class="comment">// 计算文件大小并返回</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这种设计完全违背了面向对象编程（OOP）。为什么？因为静态方法将面向对象编程变成了“面向类”编程（COP）。size()方法将类的行为都暴露出去，而不是它的对象。OOP的强大是允许我们将对象作为一种作用域分解（Scope Decomposition）的工具来用。当我在方法中实例化一个对象，它将专注于我的特定任务。它与这个方法中的其他对象是完全隔离的。这个对象在此方法作用域中是个<strong>局部变量</strong>。</p>
<h3 id="6-_对象的名字不是工作头衔">6. 对象的名字不是工作头衔</h3>
<p>一个对象的名字应该告诉我们这个对象是什么，而不是它做什么。</p>
<h3 id="7-_对象的类要么是Final，要么是Abstract">7. 对象的类要么是Final，要么是Abstract</h3>
<p>一个良好的对象要么来自一个最终类，要么来自一个抽象类。一个final类不能通过继承被扩展，一个abstract类不能实例化。最终类是个黑盒，你不能通过任何方式进行修改，唯一可以扩展最终类的方法是对它的实例进行包装。假如有个类HTTPStatus（见上），我们希望read()做得更多，在HTTP码大于400时能抛出一个异常。传统做法是扩展这个类，并重写它的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class OnlyValidStatus extends HTTPStatus {</div><div class="line">  <span class="keyword">public</span> <span class="title">OnlyValidStatus</span>(URL url) {</div><div class="line">    <span class="keyword">super</span>(url);</div><div class="line">  }</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">int</span> code = <span class="keyword">super</span>.read();</div><div class="line">    <span class="keyword">if</span> (code &gt; <span class="number">400</span>) {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimException(<span class="string">"unsuccessful HTTP code"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> code;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为什么这是错的？因为我们冒险破坏了整个父类的逻辑，因为重写了它的一个方法。一旦在子类重写了read()方法，所有来自父类的方法都会使用新版本的read()方法。字面上讲，其实这是在将一份新的“实现片段”插入到类中。理论上讲，这是种冒犯。</p>
<p>另外，扩展一个最终类，你需要把它当做一个黑盒，然后使用自己的实现来包装它，即装饰者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> class OnlyValidStatus implements Status {</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Status origin;</div><div class="line">  <span class="keyword">public</span> <span class="title">OnlyValidStatus</span>(Status status) {</div><div class="line">    <span class="keyword">this</span>.origin = status;</div><div class="line">  }</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">int</span> code = <span class="keyword">this</span>.origin.read();</div><div class="line">    <span class="keyword">if</span> (code &gt; <span class="number">400</span>) {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimException(<span class="string">"unsuccessful HTTP code"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> code;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>确保该类实现了与原始类相同的接口：Status。HTTPStatus的实例将会通过构造函数被传递和封装给它。然后所有的调用将会被拦截，如果需要，可以通过其他方式来实现。这个设计中，我们把原始对象当做黑盒，而没有触及它的内部逻辑。</p>
<p>如果没有final关键字，任何人都可以扩展这个类并且冒犯它。所以没有final的类是个糟糕的设计。</p>
<p>抽象类则完全相反，它告诉我们它是不完整的，不能直接用它，我们需要将自己的实现逻辑插入其中，但是只插入到它开放给我们的位置。这些位置被显式地标记为abstract。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> class ValidatedHTTPStatus implements Status {</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">int</span> code = <span class="keyword">this</span>.origin.read();</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isValid()) {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimException(<span class="string">"unsuccessful HTTP code"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> code;</div><div class="line">  }</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isValid</span>();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如上，这个类不能准确知道如何去验证HTTP状态码，它期望我们通过继承或者重载isValid()方法来插入那一部分逻辑。我们没法通过继承来冒犯它，因为它通过final来保护其他方法。</p>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin的笔记】Regex Note]]></title>
    <link href="http://leewin0821.github.io/2015/03/04/Regex%20Note/"/>
    <id>http://leewin0821.github.io/2015/03/04/Regex Note/</id>
    <published>2015-03-04T05:12:31.000Z</published>
    <updated>2015-03-05T12:10:23.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>为了在Java中传递模式里的反斜线字符<code>(/)</code>,应该使用双反斜线<code>(//)</code></li>
<li>如果想把圆括号解释为圆括号，在需要在前面用双反斜线<code>(//)</code></li>
<li>精确查找单词，如<code>hi</code>，需要<code>\bhi\b</code></li>
<li><code>.</code> 是另一个元字符，匹配<strong>除了换行符以外的任意字符</strong></li>
<li><code>*</code> 同样是元字符，指定<code>*</code>前面的内容可以连续重复使用任意次数以使整个表达式得到匹配</li>
<li><code>.*</code> 连在一起就表示任意数量的不包含换行的字符</li>
<li><code>+</code>和<code>*</code>都是元字符，<code>+</code>表示匹配重复一次或者多次，<code>*</code>表示重复任意次（可能是0次）</li>
</ul>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin的笔记】Spring MVC Note]]></title>
    <link href="http://leewin0821.github.io/2015/03/04/Spring%20MVC%20Note/"/>
    <id>http://leewin0821.github.io/2015/03/04/Spring MVC Note/</id>
    <published>2015-03-04T04:13:31.000Z</published>
    <updated>2015-03-05T12:27:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Request生命周期">Request生命周期</h3>
<ul>
<li><p>Request会由DispatcherServlet前端控制器（单例）分配给 Controller控制器（由HandlerMapping处理器通过请求携带的URL信息来确定映射）。</p>
</li>
<li><p>Controller会卸下Request的负载，处理信息。在Controller完成逻辑处理后，会产生需要返回用户并在浏览器上显示的信息，即Model模型。最后Controller将Model打包，并标示出用于渲染输出的View名称，Controller接下来将Model和View名称发送回DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet会使用ViewResolver视图解析器来为View名称匹配一个特定的View视图实现，它可能也可能不是JSP。随后交付Model数据给View。View使用Model数据渲染输出，并通过这个输出将响应对象传递给客户端。</p>
</li>
</ul>
<h3 id="配置DispatcherServlet">配置DispatcherServlet</h3>
<ul>
<li>配置DispatcherServlet的第一步是在web.xml中放入<code>&lt;servlet&gt;</code>声明:       </li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>application<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span></div><div class="line">		org.springframework.web.servlet.DispatcherServlet</div><div class="line">	<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></div></pre></td></tr></table></figure>

<p>默认情况下，DispatcherServlet在加载时会从一个基于这个Servlet名字的XML文件中加载Spring应用上下文。本例中即为application-servlet.xml（位于WEB-INF目录下）。</p>
<ul>
<li><p>一般推荐将DispatcherServlet映射到/，声明了它会作为默认的servlet并且会处理所有的请求，包括对静态资源的请求（Spring的mvc命名空间包含的<code>&lt;mvc:resource&gt;</code>元素处理静态资源的请求）。</p>
</li>
<li><p><code>&lt;mvc:resources mapping=“*/resources/**” location=“/resources/*”&gt;</code>表示所有以/resources路径开头的请求（包括其一下的子路径）都会自动由应用程序根目录下的/resources目录提供服务。</p>
</li>
</ul>
<h3 id="Controller的用法">Controller的用法</h3>
<ul>
<li><p>控制器类需要在类之前加上@Controller注解。@Controller是@Compnent注解的一种具体化，也就是说<code>&lt;context:component-scan&gt;</code>将查找使用@Controller注解的类并将其注册为Bean，就像它们使用@Component注解那样。因此需要在application-servlet.xml文件中配置一个 <code>&lt;context:component-scan&gt;</code>来扫描控制器类所在的文件夹。</p>
</li>
<li><p>按照约定优于配置的开发模式，Controller返回的逻辑视图名称，假设为“home”，会被Resolver自动加上前后缀来确定其JSP文件在Web应用程序中模板的路径。假设在application-servlet.xml中：  </p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">...</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"prefix"</span> <span class="attribute">value</span>=<span class="value">"/WEB-INF/views/"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"suffix"</span> <span class="attribute">value</span>=<span class="value">".jsp"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div></pre></td></tr></table></figure>

<p>那么View路径就应该是<em>/WEB-INF/views/home.jsp</em> 。</p>
<ul>
<li>为了创建被所有Servlet和Filter共享的Spring容器，需要使用Servlet监听器。ContextLoaderListener能够加载其他的配置文件到一个Spring Context中，因此先在web.xml中声明:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>  </div><div class="line">		org.springframework.web.context.ContextLoaderListener</div><div class="line">	<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然后需要给ContextLoaderListener指定加载的配置文件，默认为 <em>/WEB-INF/applicationContext.xml</em> 这个Spring配置文件。但是这个文件本身没有做到将Context拆分为多个片段。所以在需要重写默认实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">context-param</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">param-value</span>&gt;</span></div><div class="line">		/WEB-INF/application-security.xml</div><div class="line">		classpath:service-context.xml</div><div class="line">		classpath:persistence-context.xml</div><div class="line">		classpath:dataSource-context.xml</div><div class="line">	<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li><p>在处理方法的参数前面加<code>@RequestParam</code>注解，如<code>@RequestParam(&quot;spitter&quot;) String username</code>，表明参数username的值应该根据Request中名为spitter的查询参数来获取。基于约定，如果处理方法的所有参数没有注解的话，将绑定到同名的查询参数上。在本例子中，如果处理方法参数名为spitter或者查询参数名为username，这样就可以省略掉<code>@RequestParam</code>注解了。如<code>@RequestParam(value=&quot;image&quot;, required=false) MultipartFile image</code>，表明参数image为MultipartFile类型，并且这个参数不是必需的。</p>
</li>
<li><p>如果在Controller中，一个方法，如</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@RequestMapping</span>(method=RequestMethod.GET, params=<span class="string">"new"</span>)</div><div class="line"><span class="keyword">public</span> String <span class="title">createSpitterProfile</span>(Model model) {</div><div class="line">	model.addAttribute(<span class="keyword">new</span> Spitter());</div><div class="line">	<span class="keyword">return</span> <span class="string">"spitters/edit"</span>;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>它的<code>@RequestMapping</code>注解没有指定路径的话，那么这个方法会处理类级别<code>@RequestMapping</code>指定的路径，假设为 <em>/spitters</em> 。此外，将params属性设置为new，这意味着这个方法只处理对 <em>/spitters</em> 的HTTP GET请求并要求请求中必须包含名为new的查询参数。如下所示：</p>
<figure class="highlight url"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">http</span>://localhost:<span class="number">8080</span>/Spitter/spitters?<span class="built_in">new</span></div></pre></td></tr></table></figure>

<p>其中 <em>/Spitter</em> 由Servlet上下文决定，<em>/spitters</em> 由上面的Controller来处理，<em>?new</em> 就是“new”查询参数。</p>
<ul>
<li><p>View，如JSP，引用的对象存放在Model模型中。例如JSP的<code>&lt;c:forEach&gt;</code>标签的items属性以<code>${spittleList}</code>引用了Spittle列表，而spittleList就是Model的addAttribute()方法赋予它的名字。</p>
</li>
<li><p>在上面所指定的edit.jsp中，声明并使用Spring的表单绑定库：</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib prefix=<span class="string">"form"</span> uri=<span class="string">"http://www.springframework.org/tags/form"</span>%&gt;</div><div class="line">...</div><div class="line">&lt;form:form method=<span class="string">"POST"</span> modelAttribute=<span class="string">"spitter"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</div><div class="line">...</div><div class="line">&lt;form:input path=<span class="string">"fullName"</span> size=<span class="string">"15"</span> id=<span class="string">"user_full_name"</span>/&gt;</div><div class="line">...</div><div class="line">&lt;form:password path=<span class="string">"password"</span> size=<span class="string">"30"</span> showPassword=<span class="string">"true"</span> id=<span class="string">"user_password"</span>&gt;</div></pre></td></tr></table></figure>

<p><code>&lt;form:form&gt;</code>标签将上面createSpitterProfile()方法所放入Model的Spitter对象（通过modelAttribute属性来标识）绑定到表单中的各个输入域。通过将enctype设置为 <em>multipart/form-data</em>, 每个输入域都将作为POST请求的不同部分进行提交，而不仅仅是其他的名称-值。这使得在其中的某一部分包含上传的图片文件数据成为可能。 <code>&lt;form:input&gt;</code>和<code>&lt;form:password&gt;</code>标签的path属性引用表单所绑定的Spitter对象的属性。当提交表单时，这些输入域中的值会放到Spitter对象中并提交到服务器进行处理。</p>
<ul>
<li>在Controller中，如果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="string">"redirect:/spitters/"</span> + spitter.getUsername();</div></pre></td></tr></table></figure>

<p>那么执行该方法之后，请求将重新定向到指定路径，以防用户点击浏览器“刷新”按钮之后会造成表单的重复提交。</p>
<ul>
<li>谁来响应 <em>/spitters/{username}</em> 请求是个大问题，本例采用在负责对应操作的Controller的方法上打注释来解决：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@RequestMapping</span>(value=<span class="string">"/{username}"</span>, method=RequestMethod.GET)</div><div class="line"><span class="keyword">public</span> String <span class="title">showSpitterProfile</span>(@PathVariable String username, Model model) {</div><div class="line">model.addAttribute(spitterService.getSpitter(username));</div><div class="line"><span class="keyword">return</span> <span class="string">"spitters/view"</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>路径中{username}部分实际上是占位符，它对应使用了@PathVariable注解的username方法参数。请求路径中的该位置的值将作为username的值传递进去。</p>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin的笔记】Dependency Injection Note]]></title>
    <link href="http://leewin0821.github.io/2015/03/04/Dependency%20Injection%20Note/"/>
    <id>http://leewin0821.github.io/2015/03/04/Dependency Injection Note/</id>
    <published>2015-03-04T04:12:31.000Z</published>
    <updated>2015-03-05T12:29:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Dependency_Injection_Note">Dependency Injection Note</h2>
<h3 id="控制反转">控制反转</h3>
<p>假设有一个MovieLister类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    <span class="keyword">public</span> Movie[] <span class="title">moviesDirectedBy</span>(String arg)</div><div class="line">    {</div><div class="line">        List allMovies = finder.findAll();</div><div class="line">        <span class="keyword">for</span> (Iterator it = allMovies.iterator(); it.hasNext();)</div><div class="line">        {</div><div class="line">            Movie movie = (Movie) it.next();</div><div class="line">            <span class="keyword">if</span> (!movie.getDirector().equals(arg))</div><div class="line">            {</div><div class="line">                it.remove();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> (Movie[]) allMovies.toArray(<span class="keyword">new</span> Movie[allMovies.size()]);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>该类负责列出某位导演执导的所有影片，它依赖于MovieFinder接口和它的具体实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieFinder</span></span></div><div class="line">{</div><div class="line">    List findAll();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前看来还好，两个对象之间没有什么耦合关系，但是实际要搜寻影片时就必须使用MovieFinder的某个具体子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    <span class="keyword">private</span> MovieFinder finder;</div><div class="line">    <span class="keyword">public</span> <span class="title">MovieLister</span>()</div><div class="line">    {</div><div class="line">        finder = <span class="keyword">new</span> ColonDelimitedMovieFinder(<span class="string">"movies1.txt"</span>);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>问题就出在，如果想更换不同的Finder，如针对SQL，xml，web service等不同的Finder，那么必不可少就需要新的类来获取数据。如果我们想保留MovieLister里面干净漂亮的代码，又希望降低耦合性，MovieLister类只依赖于接口，这样的话如何获得一个MovieFinder子类的实例就成了问题。</p>
<p>在真实的系统中，可能存在非常多的服务和组件，如果我们希望以不同的方式部署这个系统，就需要用插件机制来处理服务之间的交互过程，这样才能在不同的部署方案中使用不同的实现。轻量级容器解决这个问题的手段都是采用控制反转模式。那么问题来了，<strong>控制反转究竟反转了哪方面的控制？</strong></p>
<p>在Martin Fowler看来，轻量级容器反转的是<strong>如何定位插件的具体实现。</strong></p>
<h3 id="依赖注入">依赖注入</h3>
<p>依赖注入模式的基本思想是：<strong>用一个单独的对象（装配器）来获得MovieFinder的一个合适的实现，并将其实例赋给MovieLister类的一个字段。</strong></p>
<p>依赖注入的形式主要有三种：</p>
<ul>
<li>构造函数注入（Constructor Injection）</li>
<li>设值方法注入（Setter Injection）</li>
<li>接口注入（Interface Injection）</li>
</ul>
<p>下面举例使用Spring进行Setter Injection：</p>
<ul>
<li>第一步，在MovieLister类中定义setter方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    <span class="keyword">private</span> MovieFinder finder;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinder</span>(MovieFinder finder)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.finder = finder;</div><div class="line">    }</div></pre></td></tr></table></figure>

<ul>
<li>第二步，相似地，在MovieFinder中定义setter方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ColonMovieFinder...</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilename</span>(String filename)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.filename = filename;</div><div class="line">    }</div></pre></td></tr></table></figure>

<ul>
<li>第三步，设定配置文件spring.xml，这里使用XML文件配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"MovieLister"</span> <span class="attribute">class</span>=<span class="value">"spring.MovieLister"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"finder"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"colonMovieFinder"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"colonMovieFinder"</span> <span class="attribute">class</span>=<span class="value">"spring.ColonMovieFinder"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filename"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>movies1.txt<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"semicolonMovieFinder"</span> <span class="attribute">class</span>=<span class="value">"spring.SemicolonMovieFinder"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filename"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>movies2.txt<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>测试代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithSpring</span>() <span class="keyword">throws</span> Exception</div><div class="line">    {</div><div class="line">        ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"spring.xml"</span>);</div><div class="line">        MovieLister lister = (MovieLister) ctx.getBean(<span class="string">"MovieLister"</span>);</div><div class="line">        Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</div><div class="line">        assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>使用依赖注入最大的好处在于：<strong>它消除了MovieLister类对具体MovieFinder实现类的依赖。</strong></p>
<h3 id="构造函数注入_VS-_设值方法注入">构造函数注入 VS. 设值方法注入</h3>
<p>构造函数注入和设值方法注入之间的选择反映的是：<strong>应该在哪里填充对象的字段，构造函数还是设值方法？</strong></p>
<p>构造函数初始化的一个好处是：你可以隐藏任何不可变的字段，只要不为它提供设值方法就行了。如果某个字段不应该被改变，那么它就不应该有设值方法。但是如果参数太多，构造函数就会显得凌乱不堪。这个地方正好是Factory Method模式适用的场合，工厂方法可以借助多个私有构造函数和设值方法的组合来完成自己的任务。问题是工厂往往以静态方法的形式出现，无法在接口中声明它们。也可以创建一个工厂类，但那就变成了另一个服务实体。</p>
<p>如果对象有多个构造函数，对象之间又存在继承关系，事情就会变得非常讨厌。为了让所有东西都正确地初始化，你必须将对子类构造函数的调用转发给超类的构造函数，然后处理自己的参数。这可能造成构造函数规模的进一步膨胀。</p>
<h3 id="代码配置_VS-_配置文件">代码配置 VS. 配置文件</h3>
<p>对大多数需要在多处部署的应用程序来说，一个单独的配置文件更合适。</p>
<p>相对的，如果应用程序的组装非常复杂，涉及大量的条件步骤，配置逻辑变得复杂的话，那么就应该用一种合适的语言来描述配置信息，使程序逻辑更清晰。然后变成一个构造器类（builder）来完成装配工作。</p>
<h3 id="分离配置与使用">分离配置与使用</h3>
<p>所有这一切的关键都在于：服务的配置应该与使用分开，正如基本的设计原则：分离接口和实现。在面向对象程序里，我们在一个地方用条件逻辑来决定具体实例化哪一个类，以后的条件分支都由多态来实现，而不是继续重复前面的条件逻辑，这就是分离接口与实现的原则。</p>
<h3 id="结论">结论</h3>
<p>开发的组件需要交给多个应用程序使用时，依赖注入模式会是更好的选择。在DI的风格中，首选构造函数注入，如果遇到了某些特定的问题，再改用设值方法注入。最重要的是将服务的配置和应用程序内部对服务的使用分离。</p>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin讲经历】从ThoughtWorks手中拿Offer]]></title>
    <link href="http://leewin0821.github.io/2014/10/21/%E3%80%90Leewin%E8%AE%B2%E7%BB%8F%E5%8E%86%E3%80%91%E4%BB%8EThoughtWorks%E6%89%8B%E4%B8%AD%E6%8B%BFOffer/"/>
    <id>http://leewin0821.github.io/2014/10/21/【Leewin讲经历】从ThoughtWorks手中拿Offer/</id>
    <published>2014-10-20T18:12:31.000Z</published>
    <updated>2014-10-22T15:12:56.000Z</updated>
    <content type="html"><![CDATA[<p>从9月底校招投递简历到10月中旬拿到Offer，ThoughtWorks真心无愧面试难度第一的公司，前前后后多轮面试真心全方位无死角地考察了每一位候选人。为了给ThoughtWorks澄清一些误会，给以后的学弟学妹提供一些帮助，我在此记录下这段时间的经历，希望能对大家有所帮助。是为序。</p>
<h2 id="谈谈流程吧">谈谈流程吧</h2>
<h3 id="Round_1：逻辑笔试">Round 1：逻辑笔试</h3>
<p>今年ThoughtWorks成都校招统一使用网投简历，宣讲会现场做逻辑题的形式。很多同学都是在这一轮被刷掉了的。其实逻辑笔试并不难，它所要求的就两点：</p>
<ol>
<li>英文要稍微过关，能读懂题意，<strong>尤其是个别单词的用法</strong>；</li>
<li>就像网上有的帖子说的那样，要<strong>像CPU一样思考</strong>，千万千万要<strong>看懂题目自带的两个例子</strong>，就算花一半时间去完全理解这两个例子也是值得的！因为一旦弄清楚了之后，后面的题目就势如破竹了。</li>
</ol>
<p>笔试大概有一个半小时，当天晚上就能收到结果，ThoughtWorks的HR效率高得惊人！</p>
<h3 id="Round_2：Homework">Round 2：Homework</h3>
<p>校招的Homework要求难度跟社招的不可同日而语，大家都是应届毕业生，水平差异大不到哪儿去，其实算都很烂，哈哈~ 个别大神写得特别好的，完全不用担心这一块儿。技术水平不高的童鞋，在做题的时候切记：</p>
<ul>
<li>一定要体现OO思想。先要在脑海里理清思路，从逻辑功能上来架构程序</li>
<li>提交之前，请先重构。Martin Fowler大爷说过：</li>
</ul>
<blockquote>
<p><em>任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员</em>。</p>
</blockquote>
<ul>
<li>单元测试不能忘。TDD在ThoughtWorks里占有很重要的角色，所以在你的Homework里面即使覆盖率不高，也得写上一两点。</li>
<li>设计模式嘛，看自身水平。生搬硬套肯定是不行的，能理解融会贯通地使用就再好不过了~</li>
</ul>
<h3 id="Round_3：HR面试">Round 3：HR面试</h3>
<p>就如同其他公司的HR面试一样，ThoughtWorks的HR面也是注重考核候选人的基本素质和非技术能力。不用担心，全情发挥，具体细节略过。</p>
<h3 id="Round_4：群面">Round 4：群面</h3>
<p>能走到这一步已经相当不容易了，相比之前的各种个人能力，群面更着重于用一个团队项目来考查候选人的团队协作能力和积极主动性。我在这一轮的表现相当不好，就不说心得了。希望学弟学妹们能在这一轮抓紧机会，好好加油！</p>
<h3 id="Round_5：技术面试">Round 5：技术面试</h3>
<p>这是今年成都校招的最后一轮面试了，和群面同一天完成。技术面试会有多个面试官对候选者提问，主要集中于Homework的设计以及候选者的项目经历。所以<strong>Homework一定不要找枪手来做</strong>，一面就会露馅的。因为校招没有Pair Programming环节，所以技术面试就显得尤为重要。</p>
<h2 id="总结一下吧">总结一下吧</h2>
<p>传说ThoughtWorks面试难度逆天，那是因为ThoughtWorks不是只简单地考察候选人的技术方面，而是<strong>全方面地了解一个候选者的能力和潜力，从中甄选出最适合ThoughtWorks的ThoughtWorker</strong>。以上。</p>
]]></content>
    
    
      <category term="Experience" scheme="http://leewin0821.github.io/tags/Experience/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://leewin0821.github.io/2014/08/04/hello-world/"/>
    <id>http://leewin0821.github.io/2014/08/04/hello-world/</id>
    <published>2014-08-04T00:39:32.000Z</published>
    <updated>2014-08-04T00:39:32.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    
  </entry>
  
</feed>
