<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Leewin’s Blog]]></title>
  <subtitle><![CDATA[□PM □UX ☑Dev]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leewin0821.github.io/"/>
  <updated>2015-03-06T12:36:50.080Z</updated>
  <id>http://leewin0821.github.io/</id>
  
  <author>
    <name><![CDATA[Leeiwn]]></name>
    <email><![CDATA[leewin.zhang@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[最小化Spring XMl配置]]></title>
    <link href="http://leewin0821.github.io/2015/03/06/Minimize%20Spring%20XML%20Configuration/"/>
    <id>http://leewin0821.github.io/2015/03/06/Minimize Spring XML Configuration/</id>
    <published>2015-03-06T12:31:15.000Z</published>
    <updated>2015-03-06T12:35:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="最小化Spring_XML配置">最小化Spring XML配置</h2>
<h3 id="自动装配Bean属性">自动装配Bean属性</h3>
<p>如果我们的应用上下文中只有一个 <em>javax.sql.DataSource</em> 类型的Bean，那么任意一个依赖 <em>DataSource</em> 的其他Bean就是需要这个 <em>DataSource</em>  Bean。毕竟这里只有一个 <em>DataSource</em>  Bean。为了应对这种明确的装配场景，Spring提供了四种自动装配（autowiring）方式：</p>
<ul>
<li>byName —— 把与Bean的属性具有相同名字（或者ID）的其他Bean自动装配到Bean的对应属性中。如果没有跟属性的名字相匹配的Bean，则该属性不进行装配。</li>
<li>byType —— 把与Bean的属性具有相同类型的其他Bean自动装配到Bean的对应属性中。如果没有跟属性的类型相匹配的Bean，则该属性不被装配。</li>
<li>constructor —— 把与Bean的构造器入参具有相同类型的其他Bean自动装配到Bean构造器的对应入参中。</li>
<li>autodetect —— 首先尝试使用constructor进行自动装配。如果失败，再尝试使用byType进行自动装配。</li>
</ul>
<h4 id="byName自动装配">byName自动装配</h4>
<p>在Spring中，所有东西都会赋予一个名字，如果属性的名字恰好与要被装配到该属性的Bean的名字匹配，Spring就将把这个Bean自动装配到该属性中去：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"kenny2"</span> <span class="attribute">class</span>=<span class="value">"com.springinaction.springidol.Instrumentalist"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"song"</span> <span class="attribute">value</span>=<span class="value">"Jingle Bells"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"instrument"</span> <span class="attribute">ref</span>=<span class="value">"saxophone"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div></pre></td></tr></table></figure>

<p>上面的配置信息中，我们使用<code>&lt;property&gt;</code>元素显式配置了Kenny的instrument属性。假设使用<code>&lt;bean&gt;</code>元素在定义Saxophone时，把Bean的id属性设置成instrument，如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"instrument"</span> <span class="attribute">class</span>=<span class="value">"com.springinaction.springidol.Saxophone"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>那么 <em>Saxophone</em> Bean的id属性就与 <em>Kenny</em> Bean的instrument属性的名字是一样的。通过配置autowire属性，Spring就可以自动装配kenny的instrument属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"kenny"</span> <span class="attribute">class</span>=<span class="value">"com.springinaction.springidol.Instrumentalist"</span> <span class="attribute">autowire</span>=<span class="value">"byName"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"song"</span> <span class="attribute">value</span>=<span class="value">"Jingle Bells"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div></pre></td></tr></table></figure>

<p>使用byName自动装配的缺点是需要假设Bean的名字与其他Bean的属性的名字一样。在本例中，如果多个 <em>Instrumentalist</em> Bean都被配置为byName自动装配，那么他们都将使用同一个instrument。</p>
<h4 id="byType自动装配">byType自动装配</h4>
<p>byType的工作方式类似于byName自动装配，但是不再是匹配属性的名字而是检查属性的类型。</p>
<p>但是byType的自动装配存在一个局限性：如果Spring寻找到多个Bean，它们的类型与需要自动装配的属性的类型都相匹配，那么Spring不会猜测哪个Bean更适合自动装配，而是选择抛出异常。所以，应用只允许存在一个Bean与需要自动装配的属性类型相匹配。</p>
<p>我们可以使用Bean的primary属性设值为false（默认为true）来标识出非首选Bean，也可以在自动装配时，通过设值Bean的autowire-candidate属性为false来排除该候选Bean。</p>
<h4 id="constructor自动装配">constructor自动装配</h4>
<p>如果要通过构造器注入来配置Bean，那我们可以移除<code>&lt;constructor-arg&gt;</code>元素，由Spring在应用上下文中自动选择Bean注入到构造器入参中。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"duke"</span> <span class="attribute">class</span>=<span class="value">"com.springinaction.springidol.PoeticJuggler"</span> <span class="attribute">autowire</span>=<span class="value">"constructor"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>上述声明告诉Spring去审视PoeticJuggler的构造器，并尝试在Spring配置中寻找匹配PoeticJuggler某一个构造器所有入参的Bean。</p>
<p>constructor自动装配具有和byType自动装配相同的局限性。</p>
<h4 id="最佳自动装配">最佳自动装配</h4>
<p>配置最佳自动装配使用如下声明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"duke"</span> <span class="attribute">class</span>=<span class="value">"com.springinaction.springidol.PoeticJuggler"</span> <span class="attribute">autowire</span>=<span class="value">"autodetect"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>当配置一个Bean的autowire属性为autodetect时，Spring将首先尝试使用constructor自动装配，如果不行再使用byType自动装配。</p>
<h4 id="默认自动装配">默认自动装配</h4>
<p>要为Spring应用上下文中的每一个Bean或者其中绝大多数配置相同的autowire属性，那么所需要做的就是在根元素<code>&lt;beans&gt;</code>上增加一个default-autowire属性。</p>
<h3 id="使用注解装配">使用注解装配</h3>
<p>使用注解自动装配与在XML中使用autowire属性自动装配并没有太大区别，但是使用注解方式允许更细粒度的自动装配，我们可以选择性地标注某一个属性来对其应用自动装配。</p>
<p>Spring容器默认禁用注解装配，所以我们需要使用Spring的context命名空间配置中的<code>&lt;context:annotation-config&gt;</code>元素来启用它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></div><div class="line"><span class="comment">&lt;!-- other spring framework declarations --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">context:annotation-config</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>Spring 3 支持几种不同的用于自动装配的注解：</p>
<h4 id="使用@Autowired">使用<code>@Autowired</code></h4>
<p>假设我们希望用<code>@Autowired</code>自动装配Instrumentalist的instrument属性，则可以对 <em>setInstrument()</em> 方法进行标注，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Autowired</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstrument</span>(Instrument instrument) {</div><div class="line">	<span class="keyword">this</span>.instrument = instrument;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当Spring发现我们对 <em>setInstrument()</em> 方法使用了<code>@Autowired</code>注解时，Spring就会尝试对该方法执行byType自动装配。</p>
<p><code>@Autowired</code>注解特别有趣的地方在于，我们不仅能使用它标注setter方法，还可以标注需要自动装配Bean引用的任意方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Autowired</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heresYourInstrument</span>(Instrument instrument) {</div><div class="line">	<span class="keyword">this</span>.instrument = instrument;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>@Autowired</code>注解甚至可以标注构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Autowired</span></div><div class="line"><span class="keyword">public</span> <span class="title">Instrumentalist</span>(Instrument instrument) {</div><div class="line">	<span class="keyword">this</span>.instrument = instrument;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当对构造器进行标注时，<code>@Autowired</code>注解表示当创建Bean时，即使在Spring XML文件中没有使用<code>&lt;constructor-arg&gt;</code>元素配置Bean，该构造器也需要进行自动装配。</p>
<p>另外，我们还可以使用<code>@Autowired</code>注解直接标注属性，并删除setter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Autowired</span></div><div class="line"><span class="keyword">private</span> Instrument instrument;</div></pre></td></tr></table></figure>

<p><code>@Autowired</code>注解甚至不会受限于 <em>private</em> 关键字，仍然可以被自动装配。</p>
<p><code>@Autowired</code>的局限是如果Spring上下文中不存在匹配的Bean或者存在多个匹配的Bean，那么<code>@Autowired</code>就会失败。解决办法是使用<code>@Qualifier</code>来消除歧义，明确指定Bean。</p>
<p>例如，为了确保Spring为 <em>eddie</em> Bean选择guitar来演奏，即使有其他Bean也可以装配到instrument属性中，但我们可以使用<code>@Qualifier</code>来明确指定名为guitar的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Autowired</span></div><div class="line"><span class="annotation">@Qualifier</span>(<span class="string">"guitar"</span>)</div><div class="line"><span class="keyword">private</span> Instrument instrument;</div></pre></td></tr></table></figure>

<p>表面上看起来使用<code>@Qualifier</code>意味着把<code>@Autowired</code>的byType自动装配转换为显式的byName装配。最重要的是，<code>@Qualifier</code>注解真正地缩小了自动装配挑选候选Bean的范围。</p>
<p>Spring的<code>@Autowired</code>注解是减少Spring XML配置的一种方式，但是使用它的类会引入对Spring的特定依赖。Spring还提供了标注的Java注解来替代<code>@Autowired</code>，即<code>@Inject</code>。</p>
<h4 id="使用@Inject">使用<code>@Inject</code></h4>
<p><code>@Inject</code>注解几乎可以完全替换Spring的<code>@Autowired</code>注解，它可以用来自动装配属性、方法和构造器。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Inject</span></div><div class="line"><span class="keyword">private</span> Instrument instrument;</div></pre></td></tr></table></figure>

<p>不同点是，<code>@Inject</code>没有 <em>required</em> 属性。因此，<code>@Inject</code>注解所标注的依赖关系必须存在，否则会抛异常。</p>
<p><code>@Inject</code>注解消除歧义使用的是<code>@Named</code>注解，工作方法类似<code>@Qualifier</code>。</p>
<h4 id="在注解注入中使用表达式">在注解注入中使用表达式</h4>
<p>Spring中可以使用<code>@Value</code>来注解装配String类型的值和基本类型的值。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Value</span>(<span class="string">"Eruption"</span>)</div><div class="line"><span class="keyword">private</span> String song;</div></pre></td></tr></table></figure>

<p>但是在java代码中硬编码这些值没有什么意义，<code>@Value</code>更重要的用处是在运行期通过SpEL动态计算复杂表达式的值并把结果装配到Bean的属性中。如上例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Value</span>(<span class="string">"#(systemProperties.myFavouriteSong)"</span>)</div><div class="line"><span class="keyword">private</span> String song;</div></pre></td></tr></table></figure>

<h3 id="自动检测Bean">自动检测Bean</h3>
<p><code>&lt;context:component-scan&gt;</code>元素除了完成与<code>&lt;context:annotation-config&gt;</code>一样的工作，还允许Spring自动检测Bean和定义Bean。这意味着不使用<code>&lt;bean&gt;</code>元素，Spring应用中的大多数（或者所有）Bean都能够实现定义和装配。为了配置Spring自动检测，需要使用<code>&lt;context:component-scan&gt;</code>来代替<code>&lt;context:annotation-config&gt;</code>元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">&lt;!-- other spring framework declarations --&gt;</div><div class="line"></div><div class="line">&lt;context:component-scan</div><div class="line">	base-package="com.springinaction.springidol" &gt;</div><div class="line">&lt;/context:component-scan&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>

<p><code>&lt;context:component-scan&gt;</code>元素会扫描指定的包及其所有子包，并查找出能够自动注册为Spring Bean的类。那么<code>&lt;context:component-scan&gt;</code>元素是如何知道哪些类需要注册为Spring Bean呢？</p>
<h4 id="为自动检测标注Bean">为自动检测标注Bean</h4>
<p>默认情况下，<code>&lt;context:component-scan&gt;</code>查找使用构造型（stereotype）注解所标注的类，这些特殊的注解如下：</p>
<ul>
<li><code>@Component</code> —— 通用的构造型注解，标识该类为Spring组件</li>
<li><code>@Controller</code> —— 标识将该类定义为Spring MVC controller</li>
<li><code>@Repository</code> —— 标识将该类定义为数据仓库</li>
<li><code>@Service</code> —— 标识将该类定义为服务</li>
<li>使用<code>@Component</code>标注的任意自定义注解</li>
</ul>
<p>假设我们的应用上下文仅仅包含eddie和guitar两个Bean。可以配置<code>&lt;context:component-scan&gt;</code>元素并使用<code>@Component</code>注解标注Instrumentalist和Guitar类，从而消除显式的<code>&lt;bean&gt;</code>定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Guitar</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span>() {</div><div class="line">		System.out.println(<span class="string">"Strum strum strum"</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Spring扫描 <em>com.springinaction.springidol</em> 包时，会发现使用<code>@Component</code>注解所标注的Guitar，并自动将它注册为Spring Bean。Bean的默认ID为无限定类名，在这种场景下， <em>Guitar</em> Bean的ID为guitar。再标注Instrumentalist类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Component</span>(<span class="string">"eddie"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentalist</span> <span class="keyword">implements</span> <span class="title">Performer</span> </span>{</div><div class="line">	<span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这种场景下，我们指定了一个Bean ID作为<code>@Component</code>注解的参数，该Bean ID不会像上一个示例一样默认设置为类的名称“instrumentalist”，而是显式命名为eddie。</p>
<h3 id="使用Spring基于Java的配置">使用Spring基于Java的配置</h3>
<h4 id="创建基于Java的配置">创建基于Java的配置</h4>
<p>即使Spring的Java配置可以让我们不使用XML就可以编写大多数的Spring配置，但是我们仍然需要极少量的XML来启用Java配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">&lt;!-- other spring framework declarations --&gt;</div><div class="line"></div><div class="line">&lt;context:component-scan</div><div class="line">	base-package="com.springinaction.springidol" &gt;</div><div class="line">&lt;/context:component-scan&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>

<p><code>&lt;context:component-scan&gt;</code>会自动注册哪些使用stereotype注解所标注的Bean，但是它也会自动加载使用<code>@Configuration</code>注解所标注的类。</p>
<h4 id="定义一个配置类">定义一个配置类</h4>
<p>在Java的配置里使用<code>@Configuration</code>注解的Java类，等价于XML配置中的<code>&lt;beans&gt;</code>元素，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringIdolConfig</span> </span>{</div><div class="line">	<span class="comment">// Bean declaration methods go here</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>@Configuration</code>注解会作为一个标识告知Spring：这个类将包含一个或多个Spring Bean定义。这些Bean的定义是使用@Bean注解所标注的方法。</p>
<h4 id="声明一个简单的Bean">声明一个简单的Bean</h4>
<p>下例使用<code>@Bean</code>注解标注一个方法来定义 <em>duke</em> Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Bean</span></div><div class="line"><span class="keyword">public</span> performer <span class="title">duke</span>() {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Juggler();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个简单例子中<code>@Bean</code>告知Spring，这个方法将返回一个对象，该对象应该被注册为Spring应用上下文中的一个Bean，方法名将作为该Bean的ID，在该方法中所实现的所有逻辑本质上都是为了创建Bean。在XML配置中，如果重命名了Juggler类，或者会忘记修改相对应的XML配置，因为XML配置中String标识符的缺点是它们无法进行编译期检查。</p>
<p>在Spring基于Java的配置中，Bean的ID和类型都被视为方法签名的一部分，Bean的实际创建是在方法体中定义的，所以可以进行编译期检查来确保Bean的类型是合法类型，并且Bean的ID是唯一的。</p>
<h4 id="使用Spring的基于Java的配置进行注入">使用Spring的基于Java的配置进行注入</h4>
<p>只需要把数字直接传入构造器中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Bean</span></div><div class="line"><span class="keyword">public</span> Performer <span class="title">duke15</span>() {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Juggler(<span class="number">15</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用setter也是一样自然的Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Bean</span></div><div class="line"><span class="keyword">public</span> Performer <span class="title">kenny</span>() {</div><div class="line">	Instrumentalist kenny = <span class="keyword">new</span> Instrumentalist();</div><div class="line">	kenny.setSong(<span class="string">"Jingle Bells"</span>);</div><div class="line">	<span class="keyword">return</span> kenny;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>装配简单值简单易懂，那么为Bean装配另一个Bean的引用呢？为了演示，首选用Java声明一个 <em>sonnet29</em> Bean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Bean</span></div><div class="line"><span class="keyword">private</span> Poem <span class="title">sonnet29</span>() {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Sonnet29();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>再创建一个 <em>PoeticJuggler</em> Bean，通过构造器为它装配 <em>sonnet29</em> Bean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Bean</span></div><div class="line"><span class="keyword">public</span> Performer <span class="title">poeticDuke</span>() {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PoeticJuggler(sonnet29());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Spring的Java配置中，通过声明方法引用一个Bean并不等同于调用该方法。如果真的这样，每次调用 <em>sonnet29()</em> ，都将得到该Bean的一个新的实例。实际上通过使用<code>@Bean</code>注解标注 <em>sonnet29()</em> 方法，会告知Spring我们希望该方法定义的Bean要被注册进Spring的应用上下文中。因此，在其他Bean的声明方法中引用这个方法时，Spring都会拦截该方法的调用，并尝试在应用上下文中查找该Bean，而不是让方法创建一个新的实例。</p>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin的笔记】Good Design of Objects Note]]></title>
    <link href="http://leewin0821.github.io/2015/03/05/Good%20Design%20of%20Objects/"/>
    <id>http://leewin0821.github.io/2015/03/05/Good Design of Objects/</id>
    <published>2015-03-05T12:20:23.000Z</published>
    <updated>2015-03-05T12:24:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="良好对象的设计">良好对象的设计</h2>
<h3 id="类和对象">类和对象</h3>
<p>类的主要职责是根据需要<strong>创建</strong>对象，以及它们不再被使用的时候<strong>销毁</strong>它们。类知道它的孩子长什么样、如何表现。换言之，类知道它们遵循的合约。</p>
<h3 id="1-_对象存在于现实生活中">1. 对象存在于现实生活中</h3>
<p>一个良好的对象，它一定可以映射到现实生活中的某个实体。如果不能，请重构。</p>
<h3 id="2-_对象根据合约办事">2. 对象根据合约办事</h3>
<p>一个良好的对象总是根据合约办事，它被期望工作是因为它遵循合约而不是它的个人优点。所有良好的对象的每个公共方法都应该实现接口中对应的方法，如果对象有公共方法没有实现任何接口，那就是糟糕的设计。</p>
<p>原因有二：</p>
<ul>
<li>首先，一个没有合约的对象不能在单元测试中进行模拟（mock）。</li>
<li>另外，无合约的对象不能通过装饰（decoration）来扩展。</li>
</ul>
<h3 id="3-_对象应该是独特的">3. 对象应该是独特的</h3>
<p>一个良好的对象应当总是封装一些东西以保持独特性，否则这个对象可能就有完全一样的克隆体，下面是一个可能有克隆的糟糕对象的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class HTTPStatus implements Status {</div><div class="line">  <span class="keyword">private</span> URL page = <span class="keyword">new</span> URL(<span class="string">"http://www.google.com"</span>);</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">return</span> HttpURLConnection.class.cast(</div><div class="line">      <span class="keyword">this</span>.page.openConnection()</div><div class="line">    ).getResponseCode();</div></pre></td></tr></table></figure>

<p>我可以创建很多HTTPStatus类的实例，但是它们都是相等的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">first = <span class="keyword">new</span> HTTPStatus();</div><div class="line">second = <span class="keyword">new</span> HTTPStatus();</div><div class="line"><span class="keyword">assert</span> first.equals(second);</div></pre></td></tr></table></figure>

<p>很明显，实用类（utility classes）可能只包含静态方法，不能实例化良好对象，严格意义上说甚至不能称作“类”。</p>
<h3 id="4-_对象是不可变的">4. 对象是不可变的</h3>
<p>一个良好的对象应该永远不改变它封装的状态。值得注意的是，不可变性并不意味着所有方法都应该返回相同的值。相反，一个良好的不可变对象是非常动态的。然后它不应该改变它的内部状态。比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Immutable</span></div><div class="line"><span class="keyword">final</span> class HTTPStatus implements Status {</div><div class="line">  <span class="keyword">private</span> URL page;</div><div class="line">  <span class="keyword">public</span> <span class="title">HTTPStatus</span>(URL url) {</div><div class="line">    <span class="keyword">this</span>.page = url;</div><div class="line">  }</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">return</span> HttpURLConnection.class.cast(</div><div class="line">      <span class="keyword">this</span>.page.openConnection()</div><div class="line">    ).getResponseCode();</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>尽管read()方法返回不同的值，但是这个对象仍然是不可变的。关于对象不可变性的优点，有如下：</p>
<ul>
<li>不可变对象创建、测试和使用更加简单</li>
<li>真正的不可变对象总是线程安全的</li>
<li>它们可以帮助避免时间耦合</li>
<li>它们的用法没有副作用，即没有防御性拷贝</li>
<li>它们总是具有失败原子性，即如果方法失败，那么对象状态应该与方法调用前一致</li>
<li>它们更容易缓存</li>
<li>它们可以防止空引用</li>
</ul>
<p>当然，一个良好的对象不应该有setter方法，因为这些方法可以改变它的状态。</p>
<h3 id="5-_对象的类不应该包含任何静态（static）的东西">5. 对象的类不应该包含任何静态（static）的东西</h3>
<p>一个静态方法实现了类的行为，而不是对象的。假设我们有个类File，它的实例都拥有size()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> class File implements Measurable {</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">    <span class="comment">// calculate the size of the file and return</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前为止，一切都还好；size()方法的存在是因为合约Measurable，每个File类的对象都可以测量自身的大小。<strong>一个可怕的错误是将类的这个方法设计为静态方法</strong>（这种类被称作实用类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕的设计，请勿使用！</span></div><div class="line">class File {</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">size</span>(String file) {</div><div class="line">    <span class="comment">// 计算文件大小并返回</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这种设计完全违背了面向对象编程（OOP）。为什么？因为静态方法将面向对象编程变成了“面向类”编程（COP）。size()方法将类的行为都暴露出去，而不是它的对象。OOP的强大是允许我们将对象作为一种作用域分解（Scope Decomposition）的工具来用。当我在方法中实例化一个对象，它将专注于我的特定任务。它与这个方法中的其他对象是完全隔离的。这个对象在此方法作用域中是个<strong>局部变量</strong>。</p>
<h3 id="6-_对象的名字不是工作头衔">6. 对象的名字不是工作头衔</h3>
<p>一个对象的名字应该告诉我们这个对象是什么，而不是它做什么。</p>
<h3 id="7-_对象的类要么是Final，要么是Abstract">7. 对象的类要么是Final，要么是Abstract</h3>
<p>一个良好的对象要么来自一个最终类，要么来自一个抽象类。一个final类不能通过继承被扩展，一个abstract类不能实例化。最终类是个黑盒，你不能通过任何方式进行修改，唯一可以扩展最终类的方法是对它的实例进行包装。假如有个类HTTPStatus（见上），我们希望read()做得更多，在HTTP码大于400时能抛出一个异常。传统做法是扩展这个类，并重写它的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class OnlyValidStatus extends HTTPStatus {</div><div class="line">  <span class="keyword">public</span> <span class="title">OnlyValidStatus</span>(URL url) {</div><div class="line">    <span class="keyword">super</span>(url);</div><div class="line">  }</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">int</span> code = <span class="keyword">super</span>.read();</div><div class="line">    <span class="keyword">if</span> (code &gt; <span class="number">400</span>) {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimException(<span class="string">"unsuccessful HTTP code"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> code;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为什么这是错的？因为我们冒险破坏了整个父类的逻辑，因为重写了它的一个方法。一旦在子类重写了read()方法，所有来自父类的方法都会使用新版本的read()方法。字面上讲，其实这是在将一份新的“实现片段”插入到类中。理论上讲，这是种冒犯。</p>
<p>另外，扩展一个最终类，你需要把它当做一个黑盒，然后使用自己的实现来包装它，即装饰者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> class OnlyValidStatus implements Status {</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Status origin;</div><div class="line">  <span class="keyword">public</span> <span class="title">OnlyValidStatus</span>(Status status) {</div><div class="line">    <span class="keyword">this</span>.origin = status;</div><div class="line">  }</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">int</span> code = <span class="keyword">this</span>.origin.read();</div><div class="line">    <span class="keyword">if</span> (code &gt; <span class="number">400</span>) {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimException(<span class="string">"unsuccessful HTTP code"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> code;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>确保该类实现了与原始类相同的接口：Status。HTTPStatus的实例将会通过构造函数被传递和封装给它。然后所有的调用将会被拦截，如果需要，可以通过其他方式来实现。这个设计中，我们把原始对象当做黑盒，而没有触及它的内部逻辑。</p>
<p>如果没有final关键字，任何人都可以扩展这个类并且冒犯它。所以没有final的类是个糟糕的设计。</p>
<p>抽象类则完全相反，它告诉我们它是不完整的，不能直接用它，我们需要将自己的实现逻辑插入其中，但是只插入到它开放给我们的位置。这些位置被显式地标记为abstract。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> class ValidatedHTTPStatus implements Status {</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">read</span>() <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">int</span> code = <span class="keyword">this</span>.origin.read();</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isValid()) {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimException(<span class="string">"unsuccessful HTTP code"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> code;</div><div class="line">  }</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isValid</span>();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如上，这个类不能准确知道如何去验证HTTP状态码，它期望我们通过继承或者重载isValid()方法来插入那一部分逻辑。我们没法通过继承来冒犯它，因为它通过final来保护其他方法。</p>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin的笔记】Regex Note]]></title>
    <link href="http://leewin0821.github.io/2015/03/04/Regex%20Note/"/>
    <id>http://leewin0821.github.io/2015/03/04/Regex Note/</id>
    <published>2015-03-04T05:12:31.000Z</published>
    <updated>2015-03-05T12:10:23.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>为了在Java中传递模式里的反斜线字符<code>(/)</code>,应该使用双反斜线<code>(//)</code></li>
<li>如果想把圆括号解释为圆括号，在需要在前面用双反斜线<code>(//)</code></li>
<li>精确查找单词，如<code>hi</code>，需要<code>\bhi\b</code></li>
<li><code>.</code> 是另一个元字符，匹配<strong>除了换行符以外的任意字符</strong></li>
<li><code>*</code> 同样是元字符，指定<code>*</code>前面的内容可以连续重复使用任意次数以使整个表达式得到匹配</li>
<li><code>.*</code> 连在一起就表示任意数量的不包含换行的字符</li>
<li><code>+</code>和<code>*</code>都是元字符，<code>+</code>表示匹配重复一次或者多次，<code>*</code>表示重复任意次（可能是0次）</li>
</ul>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin的笔记】Spring MVC Note]]></title>
    <link href="http://leewin0821.github.io/2015/03/04/Spring%20MVC%20Note/"/>
    <id>http://leewin0821.github.io/2015/03/04/Spring MVC Note/</id>
    <published>2015-03-04T04:13:31.000Z</published>
    <updated>2015-03-05T12:27:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Request生命周期">Request生命周期</h3>
<ul>
<li><p>Request会由DispatcherServlet前端控制器（单例）分配给 Controller控制器（由HandlerMapping处理器通过请求携带的URL信息来确定映射）。</p>
</li>
<li><p>Controller会卸下Request的负载，处理信息。在Controller完成逻辑处理后，会产生需要返回用户并在浏览器上显示的信息，即Model模型。最后Controller将Model打包，并标示出用于渲染输出的View名称，Controller接下来将Model和View名称发送回DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet会使用ViewResolver视图解析器来为View名称匹配一个特定的View视图实现，它可能也可能不是JSP。随后交付Model数据给View。View使用Model数据渲染输出，并通过这个输出将响应对象传递给客户端。</p>
</li>
</ul>
<h3 id="配置DispatcherServlet">配置DispatcherServlet</h3>
<ul>
<li>配置DispatcherServlet的第一步是在web.xml中放入<code>&lt;servlet&gt;</code>声明:       </li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>application<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span></div><div class="line">		org.springframework.web.servlet.DispatcherServlet</div><div class="line">	<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></div></pre></td></tr></table></figure>

<p>默认情况下，DispatcherServlet在加载时会从一个基于这个Servlet名字的XML文件中加载Spring应用上下文。本例中即为application-servlet.xml（位于WEB-INF目录下）。</p>
<ul>
<li><p>一般推荐将DispatcherServlet映射到/，声明了它会作为默认的servlet并且会处理所有的请求，包括对静态资源的请求（Spring的mvc命名空间包含的<code>&lt;mvc:resource&gt;</code>元素处理静态资源的请求）。</p>
</li>
<li><p><code>&lt;mvc:resources mapping=“*/resources/**” location=“/resources/*”&gt;</code>表示所有以/resources路径开头的请求（包括其一下的子路径）都会自动由应用程序根目录下的/resources目录提供服务。</p>
</li>
</ul>
<h3 id="Controller的用法">Controller的用法</h3>
<ul>
<li><p>控制器类需要在类之前加上@Controller注解。@Controller是@Compnent注解的一种具体化，也就是说<code>&lt;context:component-scan&gt;</code>将查找使用@Controller注解的类并将其注册为Bean，就像它们使用@Component注解那样。因此需要在application-servlet.xml文件中配置一个 <code>&lt;context:component-scan&gt;</code>来扫描控制器类所在的文件夹。</p>
</li>
<li><p>按照约定优于配置的开发模式，Controller返回的逻辑视图名称，假设为“home”，会被Resolver自动加上前后缀来确定其JSP文件在Web应用程序中模板的路径。假设在application-servlet.xml中：  </p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">...</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"prefix"</span> <span class="attribute">value</span>=<span class="value">"/WEB-INF/views/"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"suffix"</span> <span class="attribute">value</span>=<span class="value">".jsp"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div></pre></td></tr></table></figure>

<p>那么View路径就应该是<em>/WEB-INF/views/home.jsp</em> 。</p>
<ul>
<li>为了创建被所有Servlet和Filter共享的Spring容器，需要使用Servlet监听器。ContextLoaderListener能够加载其他的配置文件到一个Spring Context中，因此先在web.xml中声明:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>  </div><div class="line">		org.springframework.web.context.ContextLoaderListener</div><div class="line">	<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然后需要给ContextLoaderListener指定加载的配置文件，默认为 <em>/WEB-INF/applicationContext.xml</em> 这个Spring配置文件。但是这个文件本身没有做到将Context拆分为多个片段。所以在需要重写默认实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">context-param</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">param-value</span>&gt;</span></div><div class="line">		/WEB-INF/application-security.xml</div><div class="line">		classpath:service-context.xml</div><div class="line">		classpath:persistence-context.xml</div><div class="line">		classpath:dataSource-context.xml</div><div class="line">	<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li><p>在处理方法的参数前面加<code>@RequestParam</code>注解，如<code>@RequestParam(&quot;spitter&quot;) String username</code>，表明参数username的值应该根据Request中名为spitter的查询参数来获取。基于约定，如果处理方法的所有参数没有注解的话，将绑定到同名的查询参数上。在本例子中，如果处理方法参数名为spitter或者查询参数名为username，这样就可以省略掉<code>@RequestParam</code>注解了。如<code>@RequestParam(value=&quot;image&quot;, required=false) MultipartFile image</code>，表明参数image为MultipartFile类型，并且这个参数不是必需的。</p>
</li>
<li><p>如果在Controller中，一个方法，如</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@RequestMapping</span>(method=RequestMethod.GET, params=<span class="string">"new"</span>)</div><div class="line"><span class="keyword">public</span> String <span class="title">createSpitterProfile</span>(Model model) {</div><div class="line">	model.addAttribute(<span class="keyword">new</span> Spitter());</div><div class="line">	<span class="keyword">return</span> <span class="string">"spitters/edit"</span>;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>它的<code>@RequestMapping</code>注解没有指定路径的话，那么这个方法会处理类级别<code>@RequestMapping</code>指定的路径，假设为 <em>/spitters</em> 。此外，将params属性设置为new，这意味着这个方法只处理对 <em>/spitters</em> 的HTTP GET请求并要求请求中必须包含名为new的查询参数。如下所示：</p>
<figure class="highlight url"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">http</span>://localhost:<span class="number">8080</span>/Spitter/spitters?<span class="built_in">new</span></div></pre></td></tr></table></figure>

<p>其中 <em>/Spitter</em> 由Servlet上下文决定，<em>/spitters</em> 由上面的Controller来处理，<em>?new</em> 就是“new”查询参数。</p>
<ul>
<li><p>View，如JSP，引用的对象存放在Model模型中。例如JSP的<code>&lt;c:forEach&gt;</code>标签的items属性以<code>${spittleList}</code>引用了Spittle列表，而spittleList就是Model的addAttribute()方法赋予它的名字。</p>
</li>
<li><p>在上面所指定的edit.jsp中，声明并使用Spring的表单绑定库：</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib prefix=<span class="string">"form"</span> uri=<span class="string">"http://www.springframework.org/tags/form"</span>%&gt;</div><div class="line">...</div><div class="line">&lt;form:form method=<span class="string">"POST"</span> modelAttribute=<span class="string">"spitter"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</div><div class="line">...</div><div class="line">&lt;form:input path=<span class="string">"fullName"</span> size=<span class="string">"15"</span> id=<span class="string">"user_full_name"</span>/&gt;</div><div class="line">...</div><div class="line">&lt;form:password path=<span class="string">"password"</span> size=<span class="string">"30"</span> showPassword=<span class="string">"true"</span> id=<span class="string">"user_password"</span>&gt;</div></pre></td></tr></table></figure>

<p><code>&lt;form:form&gt;</code>标签将上面createSpitterProfile()方法所放入Model的Spitter对象（通过modelAttribute属性来标识）绑定到表单中的各个输入域。通过将enctype设置为 <em>multipart/form-data</em>, 每个输入域都将作为POST请求的不同部分进行提交，而不仅仅是其他的名称-值。这使得在其中的某一部分包含上传的图片文件数据成为可能。 <code>&lt;form:input&gt;</code>和<code>&lt;form:password&gt;</code>标签的path属性引用表单所绑定的Spitter对象的属性。当提交表单时，这些输入域中的值会放到Spitter对象中并提交到服务器进行处理。</p>
<ul>
<li>在Controller中，如果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="string">"redirect:/spitters/"</span> + spitter.getUsername();</div></pre></td></tr></table></figure>

<p>那么执行该方法之后，请求将重新定向到指定路径，以防用户点击浏览器“刷新”按钮之后会造成表单的重复提交。</p>
<ul>
<li>谁来响应 <em>/spitters/{username}</em> 请求是个大问题，本例采用在负责对应操作的Controller的方法上打注释来解决：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@RequestMapping</span>(value=<span class="string">"/{username}"</span>, method=RequestMethod.GET)</div><div class="line"><span class="keyword">public</span> String <span class="title">showSpitterProfile</span>(@PathVariable String username, Model model) {</div><div class="line">model.addAttribute(spitterService.getSpitter(username));</div><div class="line"><span class="keyword">return</span> <span class="string">"spitters/view"</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>路径中{username}部分实际上是占位符，它对应使用了@PathVariable注解的username方法参数。请求路径中的该位置的值将作为username的值传递进去。</p>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin的笔记】Dependency Injection Note]]></title>
    <link href="http://leewin0821.github.io/2015/03/04/Dependency%20Injection%20Note/"/>
    <id>http://leewin0821.github.io/2015/03/04/Dependency Injection Note/</id>
    <published>2015-03-04T04:12:31.000Z</published>
    <updated>2015-03-05T12:29:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Dependency_Injection_Note">Dependency Injection Note</h2>
<h3 id="控制反转">控制反转</h3>
<p>假设有一个MovieLister类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    <span class="keyword">public</span> Movie[] <span class="title">moviesDirectedBy</span>(String arg)</div><div class="line">    {</div><div class="line">        List allMovies = finder.findAll();</div><div class="line">        <span class="keyword">for</span> (Iterator it = allMovies.iterator(); it.hasNext();)</div><div class="line">        {</div><div class="line">            Movie movie = (Movie) it.next();</div><div class="line">            <span class="keyword">if</span> (!movie.getDirector().equals(arg))</div><div class="line">            {</div><div class="line">                it.remove();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> (Movie[]) allMovies.toArray(<span class="keyword">new</span> Movie[allMovies.size()]);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>该类负责列出某位导演执导的所有影片，它依赖于MovieFinder接口和它的具体实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieFinder</span></span></div><div class="line">{</div><div class="line">    List findAll();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前看来还好，两个对象之间没有什么耦合关系，但是实际要搜寻影片时就必须使用MovieFinder的某个具体子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    <span class="keyword">private</span> MovieFinder finder;</div><div class="line">    <span class="keyword">public</span> <span class="title">MovieLister</span>()</div><div class="line">    {</div><div class="line">        finder = <span class="keyword">new</span> ColonDelimitedMovieFinder(<span class="string">"movies1.txt"</span>);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>问题就出在，如果想更换不同的Finder，如针对SQL，xml，web service等不同的Finder，那么必不可少就需要新的类来获取数据。如果我们想保留MovieLister里面干净漂亮的代码，又希望降低耦合性，MovieLister类只依赖于接口，这样的话如何获得一个MovieFinder子类的实例就成了问题。</p>
<p>在真实的系统中，可能存在非常多的服务和组件，如果我们希望以不同的方式部署这个系统，就需要用插件机制来处理服务之间的交互过程，这样才能在不同的部署方案中使用不同的实现。轻量级容器解决这个问题的手段都是采用控制反转模式。那么问题来了，<strong>控制反转究竟反转了哪方面的控制？</strong></p>
<p>在Martin Fowler看来，轻量级容器反转的是<strong>如何定位插件的具体实现。</strong></p>
<h3 id="依赖注入">依赖注入</h3>
<p>依赖注入模式的基本思想是：<strong>用一个单独的对象（装配器）来获得MovieFinder的一个合适的实现，并将其实例赋给MovieLister类的一个字段。</strong></p>
<p>依赖注入的形式主要有三种：</p>
<ul>
<li>构造函数注入（Constructor Injection）</li>
<li>设值方法注入（Setter Injection）</li>
<li>接口注入（Interface Injection）</li>
</ul>
<p>下面举例使用Spring进行Setter Injection：</p>
<ul>
<li>第一步，在MovieLister类中定义setter方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    <span class="keyword">private</span> MovieFinder finder;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinder</span>(MovieFinder finder)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.finder = finder;</div><div class="line">    }</div></pre></td></tr></table></figure>

<ul>
<li>第二步，相似地，在MovieFinder中定义setter方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ColonMovieFinder...</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilename</span>(String filename)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.filename = filename;</div><div class="line">    }</div></pre></td></tr></table></figure>

<ul>
<li>第三步，设定配置文件spring.xml，这里使用XML文件配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"MovieLister"</span> <span class="attribute">class</span>=<span class="value">"spring.MovieLister"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"finder"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"colonMovieFinder"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"colonMovieFinder"</span> <span class="attribute">class</span>=<span class="value">"spring.ColonMovieFinder"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filename"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>movies1.txt<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"semicolonMovieFinder"</span> <span class="attribute">class</span>=<span class="value">"spring.SemicolonMovieFinder"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filename"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>movies2.txt<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>测试代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithSpring</span>() <span class="keyword">throws</span> Exception</div><div class="line">    {</div><div class="line">        ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"spring.xml"</span>);</div><div class="line">        MovieLister lister = (MovieLister) ctx.getBean(<span class="string">"MovieLister"</span>);</div><div class="line">        Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</div><div class="line">        assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>使用依赖注入最大的好处在于：<strong>它消除了MovieLister类对具体MovieFinder实现类的依赖。</strong></p>
<h3 id="构造函数注入_VS-_设值方法注入">构造函数注入 VS. 设值方法注入</h3>
<p>构造函数注入和设值方法注入之间的选择反映的是：<strong>应该在哪里填充对象的字段，构造函数还是设值方法？</strong></p>
<p>构造函数初始化的一个好处是：你可以隐藏任何不可变的字段，只要不为它提供设值方法就行了。如果某个字段不应该被改变，那么它就不应该有设值方法。但是如果参数太多，构造函数就会显得凌乱不堪。这个地方正好是Factory Method模式适用的场合，工厂方法可以借助多个私有构造函数和设值方法的组合来完成自己的任务。问题是工厂往往以静态方法的形式出现，无法在接口中声明它们。也可以创建一个工厂类，但那就变成了另一个服务实体。</p>
<p>如果对象有多个构造函数，对象之间又存在继承关系，事情就会变得非常讨厌。为了让所有东西都正确地初始化，你必须将对子类构造函数的调用转发给超类的构造函数，然后处理自己的参数。这可能造成构造函数规模的进一步膨胀。</p>
<h3 id="代码配置_VS-_配置文件">代码配置 VS. 配置文件</h3>
<p>对大多数需要在多处部署的应用程序来说，一个单独的配置文件更合适。</p>
<p>相对的，如果应用程序的组装非常复杂，涉及大量的条件步骤，配置逻辑变得复杂的话，那么就应该用一种合适的语言来描述配置信息，使程序逻辑更清晰。然后变成一个构造器类（builder）来完成装配工作。</p>
<h3 id="分离配置与使用">分离配置与使用</h3>
<p>所有这一切的关键都在于：服务的配置应该与使用分开，正如基本的设计原则：分离接口和实现。在面向对象程序里，我们在一个地方用条件逻辑来决定具体实例化哪一个类，以后的条件分支都由多态来实现，而不是继续重复前面的条件逻辑，这就是分离接口与实现的原则。</p>
<h3 id="结论">结论</h3>
<p>开发的组件需要交给多个应用程序使用时，依赖注入模式会是更好的选择。在DI的风格中，首选构造函数注入，如果遇到了某些特定的问题，再改用设值方法注入。最重要的是将服务的配置和应用程序内部对服务的使用分离。</p>
]]></content>
    
    
      <category term="Tech" scheme="http://leewin0821.github.io/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Leewin讲经历】从ThoughtWorks手中拿Offer]]></title>
    <link href="http://leewin0821.github.io/2014/10/21/%E3%80%90Leewin%E8%AE%B2%E7%BB%8F%E5%8E%86%E3%80%91%E4%BB%8EThoughtWorks%E6%89%8B%E4%B8%AD%E6%8B%BFOffer/"/>
    <id>http://leewin0821.github.io/2014/10/21/【Leewin讲经历】从ThoughtWorks手中拿Offer/</id>
    <published>2014-10-20T18:12:31.000Z</published>
    <updated>2014-10-22T15:12:56.000Z</updated>
    <content type="html"><![CDATA[<p>从9月底校招投递简历到10月中旬拿到Offer，ThoughtWorks真心无愧面试难度第一的公司，前前后后多轮面试真心全方位无死角地考察了每一位候选人。为了给ThoughtWorks澄清一些误会，给以后的学弟学妹提供一些帮助，我在此记录下这段时间的经历，希望能对大家有所帮助。是为序。</p>
<h2 id="谈谈流程吧">谈谈流程吧</h2>
<h3 id="Round_1：逻辑笔试">Round 1：逻辑笔试</h3>
<p>今年ThoughtWorks成都校招统一使用网投简历，宣讲会现场做逻辑题的形式。很多同学都是在这一轮被刷掉了的。其实逻辑笔试并不难，它所要求的就两点：</p>
<ol>
<li>英文要稍微过关，能读懂题意，<strong>尤其是个别单词的用法</strong>；</li>
<li>就像网上有的帖子说的那样，要<strong>像CPU一样思考</strong>，千万千万要<strong>看懂题目自带的两个例子</strong>，就算花一半时间去完全理解这两个例子也是值得的！因为一旦弄清楚了之后，后面的题目就势如破竹了。</li>
</ol>
<p>笔试大概有一个半小时，当天晚上就能收到结果，ThoughtWorks的HR效率高得惊人！</p>
<h3 id="Round_2：Homework">Round 2：Homework</h3>
<p>校招的Homework要求难度跟社招的不可同日而语，大家都是应届毕业生，水平差异大不到哪儿去，其实算都很烂，哈哈~ 个别大神写得特别好的，完全不用担心这一块儿。技术水平不高的童鞋，在做题的时候切记：</p>
<ul>
<li>一定要体现OO思想。先要在脑海里理清思路，从逻辑功能上来架构程序</li>
<li>提交之前，请先重构。Martin Fowler大爷说过：</li>
</ul>
<blockquote>
<p><em>任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员</em>。</p>
</blockquote>
<ul>
<li>单元测试不能忘。TDD在ThoughtWorks里占有很重要的角色，所以在你的Homework里面即使覆盖率不高，也得写上一两点。</li>
<li>设计模式嘛，看自身水平。生搬硬套肯定是不行的，能理解融会贯通地使用就再好不过了~</li>
</ul>
<h3 id="Round_3：HR面试">Round 3：HR面试</h3>
<p>就如同其他公司的HR面试一样，ThoughtWorks的HR面也是注重考核候选人的基本素质和非技术能力。不用担心，全情发挥，具体细节略过。</p>
<h3 id="Round_4：群面">Round 4：群面</h3>
<p>能走到这一步已经相当不容易了，相比之前的各种个人能力，群面更着重于用一个团队项目来考查候选人的团队协作能力和积极主动性。我在这一轮的表现相当不好，就不说心得了。希望学弟学妹们能在这一轮抓紧机会，好好加油！</p>
<h3 id="Round_5：技术面试">Round 5：技术面试</h3>
<p>这是今年成都校招的最后一轮面试了，和群面同一天完成。技术面试会有多个面试官对候选者提问，主要集中于Homework的设计以及候选者的项目经历。所以<strong>Homework一定不要找枪手来做</strong>，一面就会露馅的。因为校招没有Pair Programming环节，所以技术面试就显得尤为重要。</p>
<h2 id="总结一下吧">总结一下吧</h2>
<p>传说ThoughtWorks面试难度逆天，那是因为ThoughtWorks不是只简单地考察候选人的技术方面，而是<strong>全方面地了解一个候选者的能力和潜力，从中甄选出最适合ThoughtWorks的ThoughtWorker</strong>。以上。</p>
]]></content>
    
    
      <category term="Experience" scheme="http://leewin0821.github.io/tags/Experience/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://leewin0821.github.io/2014/08/04/hello-world/"/>
    <id>http://leewin0821.github.io/2014/08/04/hello-world/</id>
    <published>2014-08-04T00:39:32.000Z</published>
    <updated>2014-08-04T00:39:32.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    
  </entry>
  
</feed>
